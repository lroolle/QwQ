<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dream Walker</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 10;
    }

    input[type="range"] {
      width: 150px;
    }
  </style>
</head>
<body>

  <canvas id="orbitalCanvas"></canvas>

  <div id="controls">
    缩放倍数：
    <input type="range" id="scaleSlider" min="0.2" max="2" step="0.1" value="1">
    <span id="scaleValue">1.0</span>
  </div>

  <script>
    const canvas = document.getElementById('orbitalCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const slider = document.getElementById('scaleSlider');
    const scaleValue = document.getElementById('scaleValue');
    let viewScale = parseFloat(slider.value);
    slider.addEventListener('input', () => {
      viewScale = parseFloat(slider.value);
      scaleValue.textContent = viewScale.toFixed(1);
    });

    // --- 以下为你的所有动画逻辑，保留原始代码，但将 scale 修改为 viewScale ---

    // 参数配置
    const params = {
      R: 900, A1: 120, A2: 90, n: 3, m: 2, p: 4,
      w1: 0.3, w2: 0.2, w3: 0.4, H: 360,
      r0: 12, alpha: 4.5, f: 0.5,
      phiBase: Math.PI / 4, theta0: 0, omegaRot: 0.2,
      baseGlow: 0.3, beta: 0.4,
      d_thresh: 600, resonance_min: 0.7,
      gamma: 60, k: 0.08, E_critical: 3, mu: 300
    };

    let time = 0;
    const rings = [];
    const maxRings = 60;
    let mouseDown = false, mouseDownTime = 0;
    let startX, startY;
    let trailPoints = [], isDragging = false;
    let shakeAmplitude = 0;
    let viewAngleX = 0, targetViewAngleX = 0, viewTransitionSpeed = 0.05;

    class Ring {
      constructor(index) {
        this.index = index;
        this.theta = (Math.PI * 2 / maxRings) * index;
        this.phi = params.phiBase + Math.random() * Math.PI * 2;
        this.omegaRotOffset = params.omegaRot + (Math.random() - 0.5) * 0.1;
        this.active = true; this.opacity = 1;
      }

      update(t) {
        if (!this.active) {
          const elapsed = t - this.burstTime;
          if (elapsed < 1) this.opacity = 1 - elapsed;
          else this.rebirth();
        }

        const { R, A1, A2, n, m, p, w1, w2, w3, H } = params;
        const dynamicTheta = this.theta + this.index * 0.1;
        const term = A1 * Math.cos(n * dynamicTheta + w1 * t) + A2 * Math.sin(m * dynamicTheta - w2 * t);

        let x = (R + term) * Math.cos(dynamicTheta);
        let y = (R + term) * Math.sin(dynamicTheta);
        let z = H * Math.sin(p * dynamicTheta + w3 * t);

        const cosX = Math.cos(viewAngleX), sinX = Math.sin(viewAngleX);
        this.rx = x;
        this.ry = y * cosX - z * sinX;
        this.rz = y * sinX + z * cosX;

        this.radius = params.r0 + params.alpha * Math.sin(2 * Math.PI * params.f * t + this.phi);

        const rotAngle = params.theta0 + this.omegaRotOffset * t;
        this.x = this.rx * Math.cos(rotAngle) - this.ry * Math.sin(rotAngle);
        this.y = this.rx * Math.sin(rotAngle) + this.ry * Math.cos(rotAngle);
        this.z = this.rz;

        this.glow = params.baseGlow + params.beta * Math.abs(Math.sin(2 * Math.PI * params.f * t + this.phi)) + (this.clickEffect || 0);
        this.clickEffect = (this.clickEffect || 0) * 0.95;
      }

      draw(ctx, cx, cy, scale) {
        if (!this.active) return;
        const x = cx + this.x * scale;
        const y = cy + this.y * scale * 0.5;
        const radius = this.radius * (1 + this.glow) * scale * 0.5;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255,255,255,${Math.min(1, this.glow) * this.opacity})`;
        ctx.lineWidth = 2 + this.glow * 2;
        ctx.shadowBlur = 10 + this.glow * 15;
        ctx.shadowColor = 'white';
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      onClickImpact(xc, yc, zc, t) {
        const dx = this.rx - xc, dy = this.ry - yc, dz = this.rz - zc;
        const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
        const impact = params.gamma * Math.exp(-params.k * d) * Math.sin(2 * Math.PI * 0.5 * (t - (this.burstTime || 0)));
        this.clickEffect = (this.clickEffect || 0) + impact * 0.1;
      }

      burst(t) {
        this.active = false;
        this.burstTime = t;
      }

      rebirth() {
        this.active = true;
        this.opacity = 1;
        this.phi = params.phiBase + Math.random() * Math.PI * 2;
      }
    }

    for (let i = 0; i < maxRings; i++) rings.push(new Ring(i));

    canvas.addEventListener('wheel', e => {
      if (e.deltaY < 0) targetViewAngleX = Math.max(targetViewAngleX - 0.2, -Math.PI / 2);
      else targetViewAngleX = Math.min(targetViewAngleX + 0.2, Math.PI / 2);
    });

    canvas.addEventListener('mousedown', e => {
      mouseDown = true; mouseDownTime = time;
      startX = e.clientX; startY = e.clientY; isDragging = false;
    });

    canvas.addEventListener('mouseup', e => {
      mouseDown = false;
      const duration = time - mouseDownTime;
      if (isDragging) handleSwipeTrail(e.clientX, e.clientY);
      else duration >= 1.5 ? triggerBurst(time) : triggerRipple(e.clientX, e.clientY, time);
    });

    canvas.addEventListener('mousemove', e => {
      if (mouseDown) {
        isDragging = true;
        trailPoints.push({x: e.clientX, y: e.clientY});
        if (trailPoints.length > 10) trailPoints.shift();
      }
    });

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      shakeAmplitude = 1;
    });

    function triggerRipple(x, y, t) {
      const cx = width / 2, cy = height / 2, scale = 0.4 * viewScale;
      for (let ring of rings) {
        const worldX = ring.x * scale + cx, worldY = ring.y * scale + cy;
        const dx = worldX - x, dy = worldY - y, d = Math.sqrt(dx*dx + dy*dy);
        const impact = params.gamma * Math.exp(-params.k * d) * Math.sin(2 * Math.PI * 0.5 * (t - mouseDownTime));
        ring.onClickImpact(dx / scale, dy / scale, 0, t);
      }
    }

    function triggerBurst(t) {
      if (t - mouseDownTime >= params.E_critical) {
        for (let ring of rings) ring.burst(t);
      }
    }

    function handleSwipeTrail(endX, endY) {
      if (trailPoints.length < 3) return;
      const points = [...trailPoints, {x: endX, y: endY}];
      for (let i = 0; i < points.length; i++) {
        setTimeout(() => createSwipeRing(points[i].x, points[i].y, time + i * 0.1), i * 100);
      }
      trailPoints = [];
    }

    function createSwipeRing(x, y, t) {
      const cx = width / 2, cy = height / 2, scale = 0.4 * viewScale;
      const newRing = new Ring(rings.length);
      newRing.x = (x - cx) / scale;
      newRing.y = (y - cy) / scale;
      newRing.phi = params.phiBase + Math.random() * Math.PI * 2;
      newRing.update(t);
      rings.push(newRing);
      if (rings.length > 80) rings.shift();
    }

    function connectRings() {
      const connections = [];
      for (let i = 0; i < rings.length; i++) {
        for (let j = i + 1; j < rings.length; j++) {
          const a = rings[i], b = rings[j];
          if (!a.active || !b.active) continue;
          const dx = a.rx - b.rx, dy = a.ry - b.ry, dz = a.rz - b.rz;
          const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
          if (d > params.d_thresh) continue;
          const resonance = Math.cos(a.phi - b.phi);
          if (resonance < params.resonance_min) continue;
          const opacity = 1 - (d / params.d_thresh) * (1 - resonance);
          connections.push({ a, b, opacity });
        }
      }
      return connections;
    }

    function drawConnections(connections, cx, cy, scale) {
      for (let conn of connections) {
        const a = conn.a, b = conn.b;
        const x1 = cx + a.x * scale, y1 = cy + a.y * scale * 0.5;
        const x2 = cx + b.x * scale, y2 = cy + b.y * scale * 0.5;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = `rgba(255,255,255,${conn.opacity * 0.4})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      viewAngleX += (targetViewAngleX - viewAngleX) * viewTransitionSpeed;
      ctx.clearRect(0, 0, width, height);
      const cx = width / 2, cy = height / 2, scale = 0.4 * viewScale;

      if (shakeAmplitude > 0) {
        const shake = params.R * shakeAmplitude * Math.sin(2 * Math.PI * 0.5 * time);
        for (let ring of rings) ring.theta += shake / 100;
        shakeAmplitude *= 0.95;
        if (shakeAmplitude < 0.01) shakeAmplitude = 0;
      }

      for (let ring of rings) ring.update(time);
      drawConnections(connectRings(), cx, cy, scale);
      for (let ring of rings) ring.draw(ctx, cx, cy, scale);
    }

    animate();
  </script>
</body>
</html>
