<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Starborne Garden - 生命周期控制版</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            z-index: 2;
            white-space: pre;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            z-index: 10;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            align-items: center;
            color: white;
            font-family: sans-serif;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #scale-slider {
            width: 150px;
            cursor: pointer;
        }
        
        #scaleValue {
            display: inline-block;
            width: 40px;
            text-align: center;
        }
        
        /* 添加容器样式 */
        #container {
          position: absolute;
          top: 50%;
          left: 50%;
          width: 150vw;
          height: 150vh;
          transform: translate(-50%, -50%) scale(1);
          transform-origin: center center;
        }
    </style>
</head>
<body>
<div id="container">
    <canvas id="c"></canvas>
</div>
<div id="debug" style="display:none;">Debug Info</div>
<div id="controls">
  缩放倍数：
  <input type="range" id="scaleSlider" min="0.2" max="2" step="0.1" value="1">
  <span id="scaleValue">1.0</span>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const debugDiv = document.getElementById('debug');

let width, height, cx, cy, jellyWaves = [], particles = [], touchPoints = [],
    shakeOffsetX = 0, shakeOffsetY = 0;

// 新增全局变量
let globalRotationX = 0;
let globalYOffset = 0;
let isLongPress = false;
let longPressTimer = null;
let lastTouch = {x:0, y:0, time:0};
let pulseScale = 1.0;
let pressStartTime = 0;
let longPressBrightnessFactor = 0.0;

// 生命周期相关
let lifecycleStage = 'active'; // 可选值：'active', 'decay', 'fade'

// 配置参数
const config = {
    count: 150,
    speed: 0.005,
    a: 0.3,
    n: 5,
    r: 1.2,
    connectRadius: 60 * 3.5,
    maxLineWidth: 1.5,
    minLineWidth: 0.1,
    colorPresets: [
        { name: "Galaxy", startHSL: [320, 100, 50], endHSL: [200, 70, 60] },
        { name: "Ocean", startHSL: [30, 100, 50], endHSL: [160, 70, 60] },
        { name: "Solar", startHSL: [45, 100, 60], endHSL: [10, 90, 60] },
        { name: "Night", startHSL: [260, 100, 30], endHSL: [240, 100, 50] }
    ],
    currentPreset: 0,
    colorChangeSpeed: 0.001,
    brightnessRange: 0.2,
    saturationRange: 0.15,
    maxSaturation: 90,
    baseBrightness: 0.5,
    decayRate: 0.95,
    shakeIntensity: 0.02 * 3.5,
    trailAlpha: 0.15,
    trailLength: 10,
    debug: false,
    bgAlpha: 0.05,
    pulseStrength: 1.5,
    pulseDuration: 500,

    // 自动衰减阈值
    velocityThreshold: 0.1,
    alphaThreshold: 0.05
};

let currentPhase = 0;

function resize() {
    width = canvas.width = innerWidth;
    height = canvas.height = innerHeight;
    cx = width / 2;
    cy = height / 2;
}
resize();
addEventListener('resize', resize);

// 极光织网方程（带旋转）
function auroraEquation(t, i) {
    const θ = i * 0.3 + t * 0.01;
    const nt = t * config.speed;
    const r = config.r * 100 * 3.5;
    const a = config.a * 100 * 3.5;

    let x = (r + a * Math.cos(config.n * θ + nt)) * Math.cos(θ);
    let y = (r + a * Math.cos(config.n * θ + nt)) * Math.sin(θ);
    let z = a * Math.sin(config.n * θ + nt);

    // 添加 X 轴旋转
    const cosRx = Math.cos(globalRotationX);
    const sinRx = Math.sin(globalRotationX);

    const newY = y * cosRx - z * sinRx;
    const newZ = y * sinRx + z * cosRx;
    y = newY;
    z = newZ;

    return {x, y, z};
}

// 将 HSL 转换为 CSS 字符串
function hslToCss(h, s, l, a = 1) {
    return `hsla(${h}, ${s}%, ${l}%, ${a})`;
}

// 获取渐变颜色（使用 HSL）
function getGradientColor(t, phase = 0) {
    const preset = config.colorPresets[config.currentPreset];
    const waveRatio = (Math.sin((t * config.colorChangeSpeed) + phase) + 1) / 2;

    const hStart = preset.startHSL[0];
    const hEnd = preset.endHSL[0];
    const h = hStart + (hEnd - hStart) * waveRatio;

    const sStart = preset.startHSL[1];
    const sEnd = preset.endHSL[1];
    let s = sStart + (sEnd - sStart) * waveRatio;
    s = Math.min(config.maxSaturation, Math.max(10, s));

    const dynamicSaturation = config.saturationRange * Math.sin(t * 0.003 + phase) * 100;
    s = Math.min(config.maxSaturation, Math.max(10, s + dynamicSaturation));

    if (isLongPress) {
        s *= (1 - longPressBrightnessFactor * 0.8);
    }

    const brightnessBase = config.baseBrightness + config.brightnessRange * Math.sin(t * 0.002 + phase);
    const brightnessPulse = 0.1 * Math.sin(t * 0.005 + phase);
    let l = Math.floor(Math.min(95, Math.max(5, (brightnessBase + brightnessPulse) * 100)));

    if (isLongPress) {
        l = Math.min(100, l + 30 * longPressBrightnessFactor);
    }

    return hslToCss(h % 360, s, l, 0.5);
}

function initParticles() {
    particles = [];
    for (let i = 0; i < config.count; i++) {
        const pos = auroraEquation(0, i);
        particles.push({
            x: pos.x,
            y: pos.y,
            z: pos.z,
            vx: 0,
            vy: 0,
            vz: 0,
            history: [],
            alpha: 1
        });
    }
    lifecycleStage = 'active';
}

function updateParticles(t) {
    for (let p of particles) {
        const newPos = auroraEquation(t, particles.indexOf(p));
        p.vx = (newPos.x - p.x) * 0.1;
        p.vy = (newPos.y - p.y) * 0.1;
        p.vz = (newPos.z - p.z) * 0.1;

        // ✨ Q弹果冻扰动 ✨
        for (let wave of jellyWaves) {
            const dx = p.x - wave.x;
            const dy = p.y - wave.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 250) { // Q弹影响范围更大
    const tElapsed = (t - wave.time) / 60; // 让波动更慢更柔
    const force = Math.sin(tElapsed - dist / 20) * 10 * (1 - dist / 250); // 放大振幅更Q弹
    p.vx += (dx / dist) * force;
    p.vy += (dy / dist) * force;
}

        }

        // 添加交互扰动
        for (let touch of touchPoints) {
            const dx = p.x - touch.worldX;
            const dy = p.y - touch.worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < config.connectRadius * 1.5) {
                const force = (config.connectRadius * 1.5 - dist) / (config.connectRadius * 1.5) * touch.force;
                p.vx += dx / dist * force;
                p.vy += dy / dist * force;
            }
        }

        // 更新位置
        p.x += p.vx;
        p.y += p.vy;
        p.z += p.vz;

        // 历史轨迹更新
        p.history.unshift({ x: p.x, y: p.y, z: p.z });
        if (p.history.length > config.trailLength) p.history.pop();

        // 衰减
        p.vx *= config.decayRate;
        p.vy *= config.decayRate;
        p.vz *= config.decayRate;

        // 生命周期 alpha 衰减
        if (lifecycleStage === 'decay') {
            p.alpha = Math.max(0, p.alpha - 0.005);
        } else if (lifecycleStage === 'fade') {
            p.alpha = Math.max(0, p.alpha - 0.01);
        }
    }
}


// 键盘调试切换
document.addEventListener('keydown', e => {
    if (e.code === 'KeyD') {
        config.debug = !config.debug;
        debugDiv.style.display = config.debug ? 'block' : 'none';
    }
    if (e.code === 'KeyC') {
        config.currentPreset = (config.currentPreset + 1) % config.colorPresets.length;
    }
});

// pointerdown 事件处理
canvas.addEventListener('pointerdown', e => {
    
    jellyWaves.push({
    x: (e.clientX - cx) * 3 / 3.5,
    y: (e.clientY - cy) * 3 / 3.5,
    time: performance.now()
    });

    lastTouch = {
        x: e.clientX,
        y: e.clientY,
        worldX: (e.clientX - cx) * 3 / 3.5,
        worldY: (e.clientY - cy) * 3 / 3.5,
        time: performance.now()
    };

    touchPoints.push({...lastTouch, force: 5});
    pressStartTime = performance.now();
    isLongPress = false;
    longPressBrightnessFactor = 0;

    longPressTimer = setTimeout(() => {
        isLongPress = true;
        config.colorChangeSpeed *= 1.5;

        for (let p of particles) {
            const dx = p.x - lastTouch.worldX;
            const dy = p.y - lastTouch.worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < config.connectRadius * 1.5) {
                p.vx += (dx / dist) * 5;
                p.vy += (dy / dist) * 5;
            }
        }
    }, 500);
});

// pointerup 事件处理
canvas.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);

    if (isLongPress) {
        config.colorChangeSpeed /= 1.5;
        isLongPress = false;

        pulseScale = config.pulseStrength;
    }

    touchPoints = [];
});

// 禁用右键菜单，并添加生命周期控制
canvas.addEventListener('contextmenu', e => {
    e.preventDefault();

    if (lifecycleStage === 'active') {
        lifecycleStage = 'decay';
    } else if (lifecycleStage === 'decay') {
        lifecycleStage = 'fade';
    } else if (lifecycleStage === 'fade') {
        initParticles();
    }
});

// wheel 滚轮事件处理
canvas.addEventListener('wheel', e => {
    globalRotationX += e.deltaY * 0.001;
});

function drawConnections(t) {
    ctx.beginPath();
    for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        const phase1 = i * 0.3 + currentPhase;

        for (let j = i + 1; j < particles.length; j++) {
            const p2 = particles[j];
            const phase2 = j * 0.3 + currentPhase;
            const phase = (phase1 + phase2) * 0.5;

            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dz = p1.z - p2.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist < config.connectRadius && p1.alpha > 0 && p2.alpha > 0) {
                ctx.strokeStyle = getGradientColor(t, phase);
                ctx.lineWidth = config.maxLineWidth * (1 - dist / config.connectRadius) * Math.min(p1.alpha, p2.alpha);

                const scale1 = 1 / (1 + p1.z / (300 * 3.5));
                const scale2 = 1 / (1 + p2.z / (300 * 3.5));
                const screenX1 = cx + p1.x * scale1 + shakeOffsetX;
                const screenY1 = cy + (p1.y * scale1) + globalYOffset * 100 + shakeOffsetY;
                const screenX2 = cx + p2.x * scale2 + shakeOffsetX;
                const screenY2 = cy + (p2.y * scale2) + globalYOffset * 100 + shakeOffsetY;

                ctx.moveTo(screenX1, screenY1);
                ctx.lineTo(screenX2, screenY2);
            }
        }
    }
    ctx.stroke();
}

let lastFrameTime = performance.now();
let frameCount = 0;
let fps = 0;
let isShaking = false;

function animate(t) {
    frameCount++;
    jellyWaves = jellyWaves.filter(w => (t - w.time) < 1000); // 每个Q弹最多持续1秒
    if (t - lastFrameTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFrameTime = t;

        if (config.debug) {
            debugDiv.textContent = `
Lifecycle: ${lifecycleStage}
FPS: ${fps}
Current Color: ${config.colorPresets[config.currentPreset].name}
                            `.trim();
        }
    }

    // 半透明覆盖层保留残影
    ctx.fillStyle = `rgba(0,0,0,${config.bgAlpha})`;
    ctx.fillRect(0, 0, width, height);

    updateParticles(t);

    // 自动阶段转换逻辑
    if (lifecycleStage === 'active') {
        const avgVelocity = particles.reduce((sum, p) => sum + Math.hypot(p.vx, p.vy), 0) / particles.length;
        if (avgVelocity < config.velocityThreshold) {
            lifecycleStage = 'decay';
        }
    } else if (lifecycleStage === 'decay') {
        const avgAlpha = particles.reduce((sum, p) => sum + p.alpha, 0) / particles.length;
        if (avgAlpha < config.alphaThreshold) {
            lifecycleStage = 'fade';
        }
    } else if (lifecycleStage === 'fade') {
        const avgAlpha = particles.reduce((sum, p) => sum + p.alpha, 0) / particles.length;
        if (avgAlpha <= 0) {
            initParticles();
        }
    }

    // 应用晃动偏移
    if (isShaking) {
        shakeOffsetX = (Math.random() - 0.5) * 15 * 3.5;
        shakeOffsetY = (Math.random() - 0.5) * 15 * 3.5;
    } else {
        shakeOffsetX *= 0.9;
        shakeOffsetY *= 0.9;
    }

    // 处理长按增亮逻辑
    if (isLongPress) {
        const now = performance.now();
        const duration = now - pressStartTime;
        longPressBrightnessFactor = Math.min(1.0, duration / 1000);
    }

    ctx.save();
    ctx.translate(shakeOffsetX, shakeOffsetY);
    drawConnections(t);
    ctx.restore();

    requestAnimationFrame(animate);
}

initParticles();
requestAnimationFrame(animate);

// 【新增】缩放控制逻辑
const container = document.getElementById('container');
const slider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');

function setScale(factor) {
    container.style.transform = `translate(-50%, -50%) scale(${factor})`;
    scaleValue.textContent = factor.toFixed(1);
    setTimeout(resize, 10); // 确保 canvas 尺寸更新
}

slider.addEventListener('input', () => {
    setScale(parseFloat(slider.value));
});

setScale(slider.value); // 初始化缩放
</script>
</body>
</html>