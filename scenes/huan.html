<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Starborne Garden - 生命周期控制版</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
        }
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            z-index: 2;
            white-space: pre;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            z-index: 10;
            font-family: sans-serif;
        }

        #scaleValue {
            display: inline-block;
            width: 40px;
            text-align: center;
        }
    </style>
</head>
<body>
  <canvas id="c" tabindex="0" style="touch-action: none;"></canvas>


<div id="debug" style="display:none;">Debug Info</div>
<div id="controls">
  缩放倍数：
  <input type="range" id="scaleSlider" min="0.2" max="2" step="0.1" value="1">
  <span id="scaleValue">1.0</span>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const debugDiv = document.getElementById('debug');
const slider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');

let viewScale = parseFloat(slider.value);
slider.addEventListener('input', () => {
    viewScale = parseFloat(slider.value);
    scaleValue.textContent = viewScale.toFixed(1);
});

let width, height, cx, cy, particles = [], touchPoints = [],
    shakeOffsetX = 0, shakeOffsetY = 0;

let globalRotationX = 0;
let globalYOffset = 0;
let isLongPress = false;
let longPressTimer = null;
let lastTouch = {x:0, y:0, time:0};
let pulseScale = 1.0;
let pressStartTime = 0;
let longPressBrightnessFactor = 0.0;
let lifecycleStage = 'active';

const config = {
    count: 80,
    speed: 0.005,
    a: 0.3,
    n: 5,
    r: 1.2,
    connectRadius: 60 * 3.5,
    maxLineWidth: 1.5,
    minLineWidth: 0.1,
    colorPresets: [
        { name: "Galaxy", startHSL: [320, 100, 50], endHSL: [200, 70, 60] },
        { name: "Ocean", startHSL: [30, 100, 50], endHSL: [160, 70, 60] },
        { name: "Solar", startHSL: [45, 100, 60], endHSL: [10, 90, 60] },
        { name: "Night", startHSL: [260, 100, 30], endHSL: [240, 100, 50] }
    ],
    currentPreset: 0,
    colorChangeSpeed: 0.001,
    brightnessRange: 0.2,
    saturationRange: 0.15,
    maxSaturation: 90,
    baseBrightness: 0.5,
    decayRate: 0.95,
    shakeIntensity: 0.02 * 3.5,
    trailAlpha: 0.15,
    trailLength: 10,
    debug: false,
    bgAlpha: 0.1,
    pulseStrength: 1.5,
    pulseDuration: 500,
    velocityThreshold: 0.1,
    alphaThreshold: 0.05
};

let currentPhase = 0;

function resize() {
    width = canvas.width = innerWidth;
    height = canvas.height = innerHeight;
    cx = width / 2;
    cy = height / 2;
}
resize();
addEventListener('resize', resize);

function auroraEquation(t, i) {
    const θ = i * 0.3 + t * 0.01;
    const nt = t * config.speed;
    const r = config.r * 100 * viewScale;
    const a = config.a * 100 * viewScale;

    let x = (r + a * Math.cos(config.n * θ + nt)) * Math.cos(θ);
    let y = (r + a * Math.cos(config.n * θ + nt)) * Math.sin(θ);
    let z = a * Math.sin(config.n * θ + nt);

    const cosRx = Math.cos(globalRotationX);
    const sinRx = Math.sin(globalRotationX);
    const newY = y * cosRx - z * sinRx;
    const newZ = y * sinRx + z * cosRx;
    return {x, y: newY, z: newZ};
}

function hslToCss(h, s, l, a = 1) {
    return `hsla(${h}, ${s}%, ${l}%, ${a})`;
}

function getGradientColor(t, phase = 0) {
    const preset = config.colorPresets[config.currentPreset];
    const waveRatio = (Math.sin((t * config.colorChangeSpeed) + phase) + 1) / 2;

    const h = preset.startHSL[0] + (preset.endHSL[0] - preset.startHSL[0]) * waveRatio;
    let s = preset.startHSL[1] + (preset.endHSL[1] - preset.startHSL[1]) * waveRatio;
    s = Math.min(config.maxSaturation, Math.max(10, s));
    const dynamicSaturation = config.saturationRange * Math.sin(t * 0.003 + phase) * 100;
    s = Math.min(config.maxSaturation, Math.max(10, s + dynamicSaturation));

    if (isLongPress) s *= (1 - longPressBrightnessFactor * 0.8);

    const brightnessBase = config.baseBrightness + config.brightnessRange * Math.sin(t * 0.002 + phase);
    const brightnessPulse = 0.1 * Math.sin(t * 0.005 + phase);
    let l = Math.floor(Math.min(95, Math.max(5, (brightnessBase + brightnessPulse) * 100)));
    if (isLongPress) l = Math.min(100, l + 30 * longPressBrightnessFactor);

    return hslToCss(h % 360, s, l, 0.5);
}

function initParticles() {
    particles = [];
    for (let i = 0; i < config.count; i++) {
        const pos = auroraEquation(0, i);
        particles.push({ x: pos.x, y: pos.y, z: pos.z, vx: 0, vy: 0, vz: 0, history: [], alpha: 1 });
    }
    lifecycleStage = 'active';
}

function updateParticles(t) {
    for (let p of particles) {
        const newPos = auroraEquation(t, particles.indexOf(p));
        p.vx = (newPos.x - p.x) * 0.1;
        p.vy = (newPos.y - p.y) * 0.1;
        p.vz = (newPos.z - p.z) * 0.1;

        for (let touch of touchPoints) {
            const dx = p.x - touch.worldX;
            const dy = p.y - touch.worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < config.connectRadius * 1.5 * viewScale) {
                const force = (config.connectRadius * 1.5 * viewScale - dist) / (config.connectRadius * 1.5 * viewScale) * touch.force;
                p.vx += dx / dist * force;
                p.vy += dy / dist * force;
            }
        }

        p.x += p.vx;
        p.y += p.vy;
        p.z += p.vz;
        p.history.unshift({x: p.x, y: p.y, z: p.z});
        if (p.history.length > config.trailLength) p.history.pop();

        p.vx *= config.decayRate;
        p.vy *= config.decayRate;
        p.vz *= config.decayRate;

        if (lifecycleStage === 'decay') p.alpha = Math.max(0, p.alpha - 0.005);
        else if (lifecycleStage === 'fade') p.alpha = Math.max(0, p.alpha - 0.01);
    }
}

canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const worldX = (e.clientX - cx) * 3 / viewScale;
    const worldY = (e.clientY - cy) * 3 / viewScale;

    lastTouch = {
        x: e.clientX,
        y: e.clientY,
        worldX,
        worldY,
        time: performance.now()
    };

    touchPoints.push({...lastTouch, force: 5});
    pressStartTime = performance.now();
    isLongPress = false;
    longPressBrightnessFactor = 0;

    longPressTimer = setTimeout(() => {
        isLongPress = true;
        config.colorChangeSpeed *= 1.5;

        for (let p of particles) {
            const dx = p.x - worldX;
            const dy = p.y - worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < config.connectRadius * 1.5 * viewScale) {
                p.vx += (dx / dist) * 5;
                p.vy += (dy / dist) * 5;
            }
        }
    }, 500);
});

canvas.addEventListener('pointerup', e => {
    e.preventDefault();
    clearTimeout(longPressTimer);
    if (isLongPress) {
        config.colorChangeSpeed /= 1.5;
        isLongPress = false;
        pulseScale = config.pulseStrength;
    }
    touchPoints = [];
});



canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (lifecycleStage === 'active') lifecycleStage = 'decay';
    else if (lifecycleStage === 'decay') lifecycleStage = 'fade';
    else if (lifecycleStage === 'fade') initParticles();
});

canvas.addEventListener('wheel', e => {
    globalRotationX += e.deltaY * 0.001;
});

document.addEventListener('keydown', e => {
    if (e.code === 'KeyD') {
        config.debug = !config.debug;
        debugDiv.style.display = config.debug ? 'block' : 'none';
    }
    if (e.code === 'KeyC') {
        config.currentPreset = (config.currentPreset + 1) % config.colorPresets.length;
    }
});

function drawConnections(t) {
    ctx.beginPath();
    for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        const phase1 = i * 0.3 + currentPhase;
        for (let j = i + 1; j < particles.length; j++) {
            const p2 = particles[j];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dz = p1.z - p2.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist < config.connectRadius * viewScale && p1.alpha > 0 && p2.alpha > 0) {
                ctx.strokeStyle = getGradientColor(t, (phase1 + j * 0.3 + currentPhase) * 0.5);
                ctx.lineWidth = config.maxLineWidth * (1 - dist / (config.connectRadius * viewScale)) * Math.min(p1.alpha, p2.alpha);
                const scale1 = 1 / (1 + p1.z / (300 * viewScale));
                const scale2 = 1 / (1 + p2.z / (300 * viewScale));
                const screenX1 = cx + p1.x * scale1 * viewScale + shakeOffsetX;
                const screenY1 = cy + p1.y * scale1 * viewScale + globalYOffset * 100 + shakeOffsetY;
                const screenX2 = cx + p2.x * scale2 * viewScale + shakeOffsetX;
                const screenY2 = cy + p2.y * scale2 * viewScale + globalYOffset * 100 + shakeOffsetY;

                ctx.moveTo(screenX1, screenY1);
                ctx.lineTo(screenX2, screenY2);
            }
        }
    }
    ctx.stroke();
}

let lastFrameTime = performance.now();
let frameCount = 0;
let fps = 0;
let isShaking = false;

function animate(t) {
    frameCount++;
    if (t - lastFrameTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFrameTime = t;
        if (config.debug) {
            debugDiv.textContent = `Lifecycle: ${lifecycleStage}\nFPS: ${fps}\nCurrent Color: ${config.colorPresets[config.currentPreset].name}`;
        }
    }

    ctx.fillStyle = `rgba(0,0,0,${config.bgAlpha})`;
    ctx.fillRect(0, 0, width, height);
    updateParticles(t);

    if (lifecycleStage === 'active') {
        const avgV = particles.reduce((sum, p) => sum + Math.hypot(p.vx, p.vy), 0) / particles.length;
        if (avgV < config.velocityThreshold) lifecycleStage = 'decay';
    } else if (lifecycleStage === 'decay') {
        const avgA = particles.reduce((sum, p) => sum + p.alpha, 0) / particles.length;
        if (avgA < config.alphaThreshold) lifecycleStage = 'fade';
    } else if (lifecycleStage === 'fade') {
        const avgA = particles.reduce((sum, p) => sum + p.alpha, 0) / particles.length;
        if (avgA <= 0) initParticles();
    }

    if (isShaking) {
        shakeOffsetX = (Math.random() - 0.5) * 15 * viewScale;
        shakeOffsetY = (Math.random() - 0.5) * 15 * viewScale;
    } else {
        shakeOffsetX *= 0.9;
        shakeOffsetY *= 0.9;
    }

    if (isLongPress) {
        const now = performance.now();
        longPressBrightnessFactor = Math.min(1.0, (now - pressStartTime) / 1000);
    }

    ctx.save();
    ctx.translate(shakeOffsetX, shakeOffsetY);
    drawConnections(t);
    ctx.restore();

    requestAnimationFrame(animate);
}

initParticles();
window.onload = () => {
    canvas.focus();
};
 // 新增，确保canvas能接收事件
requestAnimationFrame(animate);
</script>
</body>
</html>
