<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>INSTANT POET</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=Oswald:wght@500&display=swap" rel="stylesheet">
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              mono: ['"Courier Prime"', 'monospace'],
              sans: ['"Oswald"', 'sans-serif'],
            },
            colors: {
              'instax-orange': '#D94F2B', 
              'instax-dark': '#1A1A1A',
              'instax-silver': '#E5E7EB',
              'paper-cream': '#fdfbf5',
            },
            boxShadow: {
              'cam': '0 30px 60px -10px rgba(0, 0, 0, 0.6)',
              'cam-hover': '0 40px 80px -5px rgba(0, 0, 0, 0.7)',
              'lens': 'inset 0 0 25px rgba(0,0,0,0.9), 0 5px 15px rgba(0,0,0,0.5)',
              'btn': '0 4px 8px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.5)',
              'slot': 'inset 0 -2px 4px rgba(0,0,0,0.8), 0 1px 1px rgba(255,255,255,0.3)'
            }
          }
        }
      }
    </script>
    <style>
      body {
        background-color: #f0f0f0;
        color: #111;
        overflow: hidden;
        background-image: radial-gradient(#bbb 1px, transparent 1px);
        background-size: 20px 20px;
      }
      ::-webkit-scrollbar { display: none; }
      .cursor-wait { cursor: wait; }

      /* Realistic Leather Texture */
      .leather-texture {
        background-image: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.12'/%3E%3C/svg%3E");
      }

      .typing-cursor::after {
        content: '|';
        animation: blink 1s step-start infinite;
      }
      @keyframes blink { 50% { opacity: 0; } }
    </style>
    
    <!-- UMD Scripts -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Google Generative AI -->
    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.11.3"
        }
      }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import { GoogleGenerativeAI } from "@google/generative-ai";

      // --- GLOBALS ---
      const { useState, useEffect, useRef } = React;
      const { motion, AnimatePresence } = window.Motion;

      // --- ICONS ---
      const IconWrapper = ({ children, size = 20, className, ...props }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
      );
      const Download = (props) => <IconWrapper {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></IconWrapper>;
      const Trash2 = (props) => <IconWrapper {...props}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></IconWrapper>;
      const RefreshCw = (props) => <IconWrapper {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></IconWrapper>;
      const Key = (props) => <IconWrapper {...props}><path d="m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4" /></IconWrapper>;

      // --- SERVICES ---
      const generatePhotoCaption = async ({ imageBase64, language, apiKey }) => {
        if (!apiKey) return "Please set API Key.";
        try {
          const genAI = new GoogleGenerativeAI(apiKey);
          const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
          const cleanBase64 = imageBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');
          
          const prompt = `
            Analyze this image. 
            Write a short, evocative poem or caption.
            Bilingual (English & Chinese).
            Style: Retro, Polaroid memory, Wong Kar-wai, Intimate.
            
            FORMAT:
            Use *asterisks* for emphasis.
            Keep it under 25 words.
            
            Example:
            The coffee was *cold* before I noticed.
            *Waiting* / 等待
          `;
          
          const result = await model.generateContent([prompt, { inlineData: { data: cleanBase64, mimeType: "image/png" } }]);
          const response = await result.response;
          return response.text().trim() || "A moment frozen in *time*.\n*Silence* / 沉默";
        } catch (error) {
          console.error(error);
          return "Error developing memory.\n*Void* / 空";
        }
      };

      // --- COMPONENTS ---

      // Smart Typewriter: Handles styled text streaming
      const SmartTypewriter = ({ text, seed }) => {
         const [visibleCount, setVisibleCount] = useState(0);
         
         // Tokenize text: split by *markers* and \n
         const { tokens, fullLength } = React.useMemo(() => {
             if (!text) return { tokens: [], fullLength: 0 };
             
             const t = [];
             const colors = ['text-instax-orange', 'text-emerald-600', 'text-indigo-600', 'text-rose-600', 'text-amber-600', 'text-cyan-600', 'text-fuchsia-600'];
             
             // Deterministic color selection based on seed (photo.id)
             // This ensures the same photo always gets the same highlight color
             let hash = 0;
             const safeSeed = seed || ''; 
             for (let i = 0; i < safeSeed.length; i++) {
                hash = safeSeed.charCodeAt(i) + ((hash << 5) - hash);
             }
             const assignedColor = colors[Math.abs(hash) % colors.length];
             
             const lines = text.split('\n');
             lines.forEach((line, i) => {
                 const parts = line.split(/(\*[^*]+\*)/g);
                 parts.forEach(part => {
                     if (!part) return;
                     if (part.startsWith('*') && part.endsWith('*')) {
                         t.push({ text: part.slice(1, -1), type: 'highlight', color: assignedColor });
                     } else {
                         t.push({ text: part, type: 'normal' });
                     }
                 });
                 if (i < lines.length - 1) t.push({ text: '\n', type: 'newline' });
             });
             
             // Calculate plain text length for typing logic
             const len = t.reduce((acc, token) => acc + (token.type === 'newline' ? 1 : token.text.length), 0);
             return { tokens: t, fullLength: len };
         }, [text, seed]);

         // Typing Animation
         useEffect(() => {
             setVisibleCount(0);
             if (!fullLength) return;

             const interval = setInterval(() => {
                 setVisibleCount(prev => {
                     if (prev >= fullLength) {
                         clearInterval(interval);
                         return prev;
                     }
                     return prev + 1;
                 });
             }, 40); // 40ms per char
             return () => clearInterval(interval);
         }, [text, fullLength]);

         // Render based on visibleCount budget
         let budget = visibleCount;
         
         return (
            <div className="font-mono text-[13px] leading-normal text-gray-800 min-h-[20px]">
                {tokens.map((token, i) => {
                    if (budget <= 0) return null;
                    
                    if (token.type === 'newline') {
                        budget--;
                        return <br key={i} />;
                    }
                    
                    const showTxt = token.text.slice(0, budget);
                    budget -= showTxt.length;
                    
                    if (token.type === 'highlight') {
                        return (
                            <span key={i} className={`${token.color} font-bold`}>
                                {showTxt}
                            </span>
                        );
                    }
                    
                    return <span key={i}>{showTxt}</span>;
                })}
                {visibleCount < fullLength && <span className="typing-cursor text-orange-500 ml-1 opacity-70"></span>}
            </div>
         );
      };

      const PhotoCard = ({ photo, onDelete, onUpdateCaption, onDragEnd, browserLang, apiKey }) => {
        const [isHovered, setIsHovered] = useState(false);
        const [isRegenerating, setIsRegenerating] = useState(false);
        const cardRef = useRef(null);

        const dateStr = new Date(photo.timestamp).toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
        
        const isDeveloping = photo.status === 'developing';
        const isDeveloped = photo.status === 'developed';

        const handleDownload = async (e) => {
          e.stopPropagation();
          if (cardRef.current) {
            const tools = cardRef.current.querySelector('.photo-tools');
            if (tools) tools.style.display = 'none';
            try {
                const canvas = await html2canvas(cardRef.current, { scale: 4, backgroundColor: '#fafafa', useCORS: true });
                const link = document.createElement('a');
                link.download = `INSTANT-${photo.timestamp}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } finally { if (tools) tools.style.display = ''; }
          }
        };

        const handleRegenerate = async (e) => {
            e.stopPropagation();
            if (!apiKey) { alert("API Key Required"); return; }
            setIsRegenerating(true);
            // Clear caption to trigger typewriter effect again on update
            onUpdateCaption(photo.id, ""); 
            const newCaption = await generatePhotoCaption({ imageBase64: photo.imageUrl, language: browserLang, apiKey });
            onUpdateCaption(photo.id, newCaption);
            setIsRegenerating(false);
        };

        const transitionConfig = isDeveloping 
          ? { y: { duration: 2.5, ease: [0.2, 0.6, 0.3, 1] }, default: { duration: 0.5 } }
          : { type: "spring", stiffness: 80, damping: 15 };

        return (
          <motion.div
            ref={cardRef}
            initial={{ x: photo.x, y: photo.y, rotate: 0, scale: 0.95 }}
            animate={{ x: photo.x, y: photo.y, rotate: photo.rotation, scale: 1 }}
            transition={transitionConfig}
            drag dragMomentum={false}
            onDragEnd={(_, info) => onDragEnd(photo.id, photo.x + info.offset.x, photo.y + info.offset.y)}
            onHoverStart={() => setIsHovered(true)}
            onHoverEnd={() => setIsHovered(false)}
            className="absolute flex flex-col bg-[#fafafa] shadow-[0_12px_24px_-6px_rgba(0,0,0,0.15),0_1px_3px_rgba(0,0,0,0.1)] ring-1 ring-black/5 cursor-grab active:cursor-grabbing select-none"
            style={{ width: '250px', padding: '14px 14px 50px 14px', zIndex: isHovered ? 50 : 10 }}
          >
            <div className="w-full aspect-[3/4] relative bg-[#111] overflow-hidden mb-3 shadow-[inset_0_1px_4px_rgba(0,0,0,0.2)] ring-1 ring-black/5">
               <motion.img 
                  src={photo.imageUrl} 
                  className="w-full h-full object-cover pointer-events-none"
                  initial={{ filter: 'blur(20px) grayscale(100%) brightness(0.3)' }}
                  animate={{ 
                      filter: isDeveloped ? 'blur(0px) grayscale(0%) brightness(1)' : 'blur(20px) grayscale(100%) brightness(0.3)' 
                  }}
                  transition={{ duration: 4.5, ease: [0.1, 0.8, 0.2, 1] }} 
               />
               <div className="absolute inset-0 bg-gradient-to-tr from-transparent to-white/10 pointer-events-none"></div>
            </div>

            <div className="min-h-[2.5rem] px-1 relative">
                {photo.caption ? (
                   <SmartTypewriter text={photo.caption} seed={photo.id} />
                ) : (
                   // Show cursor while waiting for initial text or regeneration
                   <div className="typing-cursor text-orange-500 ml-1 opacity-70"></div>
                )}
                <div className="absolute bottom-[-30px] right-0 text-[8px] font-mono text-gray-400 tracking-widest">{dateStr}</div>
            </div>

            {isHovered && (
              <div className="photo-tools absolute -top-3 -right-3 flex gap-1 z-50">
                 <button onClick={handleDownload} className="p-1.5 bg-white shadow-md rounded-full hover:text-instax-orange transition-colors" title="Save"><Download size={14} /></button>
                 <button onClick={handleRegenerate} className={`p-1.5 bg-white shadow-md rounded-full hover:text-instax-orange transition-colors ${isRegenerating ? 'animate-spin' : ''}`} title="Rewrite"><RefreshCw size={14} /></button>
                 <button onClick={() => onDelete(photo.id)} className="p-1.5 bg-white shadow-md rounded-full hover:text-red-600 transition-colors" title="Discard"><Trash2 size={14} /></button>
              </div>
            )}
          </motion.div>
        );
      };

      const App = () => {
        const videoRef = useRef(null);
        const [stream, setStream] = useState(null);
        const [photos, setPhotos] = useState([]);
        const [isProcessing, setIsProcessing] = useState(false); 
        const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
        const [showApiKeyModal, setShowApiKeyModal] = useState(!localStorage.getItem('gemini_api_key'));
        const browserLang = navigator.language || 'en-US';

        const CAMERA_WIDTH = 350;
        const CAMERA_HEIGHT = 340;
        const CAMERA_LEFT = 50;
        const CAMERA_BOTTOM = 50;

        const [cameraX, setCameraX] = useState(CAMERA_LEFT);
        const [cameraY, setCameraY] = useState(window.innerHeight - CAMERA_BOTTOM - CAMERA_HEIGHT);

        useEffect(() => {
          const startCamera = async () => {
            try {
              const mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 720 } }, audio: false });
              setStream(mediaStream);
              if (videoRef.current) videoRef.current.srcObject = mediaStream;
            } catch (err) { console.error(err); }
          };
          startCamera();
          return () => { if (stream) stream.getTracks().forEach(track => track.stop()); };
        }, []);

        const saveApiKey = (key) => { localStorage.setItem('gemini_api_key', key); setApiKey(key); setShowApiKeyModal(false); };

        const playSound = (type) => {
           const AC = window.AudioContext || window.webkitAudioContext;
           if(!AC) return;
           const ctx = new AC();
           const osc = ctx.createOscillator();
           const gain = ctx.createGain();
           
           if (type === 'shutter') {
             osc.type = 'square';
             osc.frequency.setValueAtTime(400, ctx.currentTime);
             osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
             gain.gain.setValueAtTime(0.3, ctx.currentTime);
             gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
             osc.connect(gain); gain.connect(ctx.destination);
             osc.start(); osc.stop(ctx.currentTime + 0.1);
           } else if (type === 'motor') {
             osc.type = 'sawtooth';
             osc.frequency.setValueAtTime(120, ctx.currentTime);
             osc.frequency.linearRampToValueAtTime(140, ctx.currentTime + 2.0);
             gain.gain.setValueAtTime(0.08, ctx.currentTime);
             gain.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 2.0);
             gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 2.5);
             const filter = ctx.createBiquadFilter();
             filter.type = 'lowpass'; filter.frequency.value = 400;
             osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
             osc.start(); osc.stop(ctx.currentTime + 2.5);
           }
        };

        const takePhoto = async () => {
           if (!videoRef.current || isProcessing) return;
           setIsProcessing(true);
           playSound('shutter'); 

           const video = videoRef.current;
           const canvas = document.createElement('canvas');
           const w = video.videoWidth;
           const h = video.videoHeight;
           const cropSize = Math.min(w, h);
           const captureW = cropSize * 0.75; 
           const captureH = cropSize;
           
           canvas.width = 600; canvas.height = 800; 
           const ctx = canvas.getContext('2d');
           ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
           ctx.drawImage(video, (w - captureW)/2, (h - captureH)/2, captureW, captureH, 0, 0, canvas.width, canvas.height);
           
           const tempId = Date.now().toString();
           const slotY = cameraY + 28; 
           const spawnX = cameraX + (CAMERA_WIDTH / 2) - 120; 
           
           const newPhoto = {
             id: tempId,
             imageUrl: canvas.toDataURL('image/webp', 0.9),
             caption: '', // Start empty
             timestamp: Date.now(),
             status: 'processing', // Inside camera
             x: spawnX, 
             y: slotY + 200, 
             rotation: 0
           };
           
           setPhotos(prev => [...prev, newPhoto]);

           // Trigger Ejection quickly (400ms after shutter sound)
           setTimeout(() => {
               playSound('motor');
               setPhotos(prev => prev.map(p => p.id === tempId ? { 
                   ...p, 
                   status: 'developing', // Eject & Develop
                   y: slotY - 320 
               } : p));
               setIsProcessing(false); // Ready for next shot
           }, 400);

           // Generate Text in background
           if (apiKey) {
              generatePhotoCaption({ imageBase64: newPhoto.imageUrl, language: browserLang, apiKey })
                  .then(caption => {
                      setPhotos(prev => prev.map(p => p.id === tempId ? { ...p, caption } : p));
                  })
                  .catch(() => {
                      setPhotos(prev => prev.map(p => p.id === tempId ? { ...p, caption: "..." } : p));
                  });
           }

           // Drift logic
           setTimeout(() => {
               setPhotos(prev => prev.map(p => p.id === tempId ? {
                   ...p,
                   y: window.innerHeight / 2 - 200 + (Math.random() * 100 - 50),
                   x: window.innerWidth / 2 - 120 + (Math.random() * 200 - 100),
                   rotation: (Math.random() * 10 - 5)
               } : p));
           }, 3000); 
           
           // Finish Developing
           setTimeout(() => {
              setPhotos(prev => prev.map(p => p.id === tempId ? { ...p, status: 'developed' } : p));
           }, 8000); 
        };

        return (
          <div className="w-screen h-screen relative select-none overflow-hidden font-mono">
            {/* BACKGROUND TYPOGRAPHY */}
            <div className="absolute inset-0 z-0 pointer-events-none overflow-hidden select-none">
                {/* Brand Watermark */}
                <h1 className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[25vw] font-sans font-bold text-[#e5e5e5] opacity-40 tracking-tighter transform -rotate-6 blur-[1px]">
                    ANTHOLOGY
                </h1>
                
                {/* Floating poetic fragments */}
                <div className="absolute top-12 left-12 font-mono text-xs text-gray-400 tracking-[0.3em] opacity-60">
                    FIG. 001 — MEMORY ARCHIVE
                </div>
                
                <div className="absolute bottom-12 right-12 text-right">
                    <p className="font-serif italic text-2xl text-gray-300 opacity-50 leading-none mb-2">
                        "Time is the substance<br/>I am made of."
                    </p>
                    <span className="font-mono text-[9px] text-gray-300 tracking-widest uppercase block">
                        — J.L. Borges
                    </span>
                </div>

                <div className="absolute top-1/4 right-[10%] w-[1px] h-32 bg-gradient-to-b from-transparent via-gray-300 to-transparent opacity-50"></div>
                <div className="absolute bottom-1/3 left-[15%] w-32 h-[1px] bg-gradient-to-r from-transparent via-gray-300 to-transparent opacity-50"></div>
            </div>
            
            {/* PHOTO WALL */}
            <div className="absolute inset-0 z-10 pointer-events-none">
               <div className="w-full h-full pointer-events-auto">
                   <AnimatePresence>
                     {photos.map(p => (
                        <div key={p.id} className="absolute" style={{ zIndex: p.status === 'processing' ? 5 : 15 }}>
                            <PhotoCard photo={p} onDelete={id => setPhotos(prev => prev.filter(x => x.id !== id))} onUpdateCaption={(id, c) => setPhotos(prev => prev.map(x => x.id === id ? {...x, caption: c} : x))} onDragEnd={(id, x, y) => setPhotos(prev => prev.map(item => item.id === id ? { ...item, x, y } : item))} browserLang={browserLang} apiKey={apiKey} />
                        </div>
                     ))}
                   </AnimatePresence>
               </div>
            </div>

            {/* CAMERA OBJECT */}
            <motion.div
              drag dragMomentum={false}
              onDragEnd={(_, info) => { setCameraX(info.point.x - CAMERA_WIDTH / 2); setCameraY(info.point.y - CAMERA_HEIGHT / 2); }}
              initial={{ x: cameraX, y: cameraY }}
              animate={{ x: cameraX, y: cameraY }}
              className="fixed flex flex-col items-center group transition-transform duration-500 hover:scale-[1.02] cursor-grab active:cursor-grabbing"
              style={{
                width: `${CAMERA_WIDTH}px`,
                height: `${CAMERA_HEIGHT}px`,
                // Removed fixed bottom/left/top/right in favor of Framer Motion's x/y
                zIndex: 20 
              }}
            >
                {/* Camera Body */}
                <div className="relative w-full h-full rounded-[30px] shadow-cam group-hover:shadow-cam-hover transition-shadow duration-500 flex flex-col overflow-hidden">
                    <div className="absolute inset-0 bg-instax-orange leather-texture"></div>
                    
                    {/* 3D Slot */}
                    <div className="absolute top-0 left-1/2 -translate-x-1/2 w-3/4 h-5 bg-gradient-to-b from-[#222] to-[#111] shadow-slot rounded-b-xl z-10 border-x border-b border-[#444] opacity-90"></div>

                    {/* Top Plate */}
                    <div className="h-1/4 bg-gradient-to-b from-[#fff] to-[#ddd] relative z-20 rounded-t-[30px] border-b border-[#bbb] flex items-center justify-between px-6 shadow-sm">
                        {/* Flash */}
                        <div className="w-16 h-8 bg-[#f8f8f8] border-2 border-gray-400 rounded-md shadow-inner relative overflow-hidden group-hover:brightness-110 transition-all">
                            <div className="absolute inset-0 bg-[repeating-linear-gradient(90deg,transparent,transparent_2px,#e5e5e5_2px,#e5e5e5_4px)]"></div>
                            <div className={`absolute top-1 right-1 w-2 h-2 rounded-full ${isProcessing ? 'bg-red-500 animate-pulse shadow-[0_0_5px_red]' : 'bg-gray-300'}`}></div>
                        </div>
                        {/* Viewfinder */}
                        <div className="w-10 h-10 bg-[#111] rounded-full border-4 border-[#ccc] shadow-inner flex items-center justify-center overflow-hidden">
                            <div className="w-full h-full opacity-30 bg-gradient-to-br from-blue-500 to-transparent group-hover:opacity-50 transition-opacity"></div>
                        </div>
                    </div>

                    {/* Lens Area */}
                    <div className="flex-1 relative flex items-center justify-center">
                        {/* Lens Assembly */}
                        <div className="w-56 h-56 rounded-full bg-[#222] shadow-lens flex items-center justify-center border-[8px] border-[#e5e5e5] relative">
                            {/* Settings Dial */}
                            <button onClick={() => setShowApiKeyModal(true)} className="absolute -left-4 top-1/2 -translate-y-1/2 w-9 h-14 bg-[#2a2a2a] border border-gray-600 rounded-l-lg flex items-center justify-center text-gray-400 hover:text-white transition-colors shadow-lg cursor-pointer hover:scale-105 active:scale-95" title="Settings">
                                <Key size={14} />
                            </button>
                            {/* Inner Lens */}
                            <div className="w-40 h-40 rounded-full bg-black border-4 border-[#1a1a1a] overflow-hidden relative group/lens">
                                 <video ref={videoRef} autoPlay playsInline muted className="w-full h-full object-cover opacity-90 transform scale-x-[-1]" />
                                 <div className="absolute top-[-20%] right-[-20%] w-[80%] h-[80%] bg-white/10 rounded-full blur-xl pointer-events-none group-hover/lens:bg-white/20 transition-colors"></div>
                            </div>
                        </div>

                        {/* Shutter Button */}
                        <button 
                           onClick={takePhoto}
                           disabled={isProcessing}
                           className={`absolute right-6 top-1/2 transform -translate-y-1/2 w-16 h-16 rounded-full bg-[#f0f0f0] border-4 border-[#ccc] shadow-btn flex items-center justify-center active:scale-95 active:shadow-inner transition-all ${isProcessing ? 'cursor-wait' : 'hover:border-white'}`}
                        >
                            <div className="w-12 h-12 rounded-full bg-[#222] shadow-[inset_0_2px_5px_rgba(0,0,0,0.5)]"></div>
                        </button>
                    </div>
                    
                    <div className="absolute right-0 bottom-0 w-1/4 h-1/2 bg-black/10 rounded-tl-[40px] pointer-events-none"></div>
                </div>
            </motion.div>

            {/* MODAL */}
            {showApiKeyModal && (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-sm">
                    <div className="bg-white rounded-lg p-8 max-w-md w-full shadow-2xl border-4 border-instax-orange">
                        <h2 className="font-sans text-3xl mb-2 font-bold text-instax-dark">SETUP</h2>
                        <p className="font-mono text-xs mb-6 text-gray-500">ENTER YOUR GEMINI API KEY</p>
                        <input type="password" className="w-full bg-gray-100 border-2 border-black p-3 font-mono text-lg focus:outline-none mb-6" placeholder="AIza..." defaultValue={apiKey} onBlur={e => saveApiKey(e.target.value)} />
                        <div className="flex justify-end">
                            <button onClick={() => setShowApiKeyModal(false)} className="bg-instax-orange text-white px-6 py-2 font-bold font-sans tracking-wider hover:bg-instax-dark transition-colors">READY</button>
                        </div>
                    </div>
                </div>
            )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
