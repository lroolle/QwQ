<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bao Retro Camera</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              handwritten: ['"Patrick Hand"', 'cursive'],
            },
            colors: {
              paper: '#fdfbf7',
            }
          }
        }
      }
    </script>
    <style>
      body {
        background-color: #e5e5f7;
        background-image:  radial-gradient(#444cf7 0.5px, transparent 0.5px), radial-gradient(#444cf7 0.5px, #e5e5f7 0.5px);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
        overflow: hidden;
      }
      ::-webkit-scrollbar { display: none; }
      .cursor-wait { cursor: wait; }
    </style>
    
    <!-- UMD Scripts: These load global variables: React, ReactDOM, Motion -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Framer Motion UMD -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <!-- HTML2Canvas -->
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Google Generative AI (ESM) -->
    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.11.3"
        }
      }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import { GoogleGenerativeAI } from "@google/generative-ai";

      // --- GLOBALS ---
      const { useState, useEffect, useRef } = React;
      const { motion, AnimatePresence } = window.Motion;
      // html2canvas is globally available as html2canvas

      // --- ICONS (Inlined to avoid dependency issues) ---
      const IconWrapper = ({ children, size = 24, className, ...props }) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={size} 
          height={size} 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={className} 
          {...props}
        >
          {children}
        </svg>
      );

      const Info = (props) => (
        <IconWrapper {...props}>
          <circle cx="12" cy="12" r="10" />
          <path d="M12 16v-4" />
          <path d="M12 8h.01" />
        </IconWrapper>
      );

      const Download = (props) => (
        <IconWrapper {...props}>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" x2="12" y1="15" y2="3" />
        </IconWrapper>
      );

      const Trash2 = (props) => (
        <IconWrapper {...props}>
          <path d="M3 6h18" />
          <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
          <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
          <line x1="10" x2="10" y1="11" y2="17" />
          <line x1="14" x2="14" y1="11" y2="17" />
        </IconWrapper>
      );

      const Edit2 = (props) => (
        <IconWrapper {...props}>
          <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" />
        </IconWrapper>
      );

      const RefreshCw = (props) => (
        <IconWrapper {...props}>
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
          <path d="M21 3v5h-5" />
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
          <path d="M8 16H3v5" />
        </IconWrapper>
      );

      const Check = (props) => (
        <IconWrapper {...props}>
          <polyline points="20 6 9 17 4 12" />
        </IconWrapper>
      );

      const X = (props) => (
        <IconWrapper {...props}>
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </IconWrapper>
      );

      const Key = (props) => (
        <IconWrapper {...props}>
          <path d="m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4" />
        </IconWrapper>
      );


      // --- SERVICES ---

      const generatePhotoCaption = async ({ imageBase64, language, apiKey }) => {
        if (!apiKey) return "Please set API Key.";

        try {
          const genAI = new GoogleGenerativeAI(apiKey);
          const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

          const cleanBase64 = imageBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');

          const prompt = `
            Analyze this image. 
            Write a very short, warm, nostalgic, and handwritten-style blessing or nice comment about the photo.
            The tone should be like a memory keeper.
            Language: ${language}.
            Maximum 12 words.
            Wrap 1-2 key emotional words in asterisks like *this* for highlighting.
            Do not include quotes.
          `;

          const result = await model.generateContent([
            prompt,
            { inlineData: { data: cleanBase64, mimeType: "image/png" } }
          ]);
          const response = await result.response;
          return response.text().trim() || "A beautiful moment captured.";
        } catch (error) {
          console.error("Error generating caption:", error);
          return "Moment frozen in time.";
        }
      };

      // --- COMPONENTS ---

      const PhotoCard = ({ photo, onDelete, onUpdateCaption, onDragEnd, browserLang, apiKey }) => {
        const [isHovered, setIsHovered] = useState(false);
        const [isEditing, setIsEditing] = useState(false);
        const [editText, setEditText] = useState(photo.caption);
        const [isRegenerating, setIsRegenerating] = useState(false);
        const cardRef = useRef(null);

        const dateStr = new Date(photo.timestamp).toLocaleDateString(browserLang, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });

        const handleDownload = async (e) => {
          e.stopPropagation();
          if (cardRef.current) {
            const canvas = await html2canvas(cardRef.current, {
              scale: 2,
              backgroundColor: null,
              ignoreElements: (element) => element.classList.contains('photo-tools'),
            });
            
            const link = document.createElement('a');
            link.download = `bao-retro-${photo.timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
          }
        };

        const handleRegenerate = async (e) => {
          e.stopPropagation();
          if (!apiKey) {
            alert("Please set your Gemini API Key first!");
            return;
          }
          setIsRegenerating(true);
          const newCaption = await generatePhotoCaption({
            imageBase64: photo.imageUrl,
            language: browserLang,
            apiKey
          });
          onUpdateCaption(photo.id, newCaption);
          setEditText(newCaption);
          setIsRegenerating(false);
        };

        const saveEdit = () => {
          onUpdateCaption(photo.id, editText);
          setIsEditing(false);
        };

        const cancelEdit = () => {
          setEditText(photo.caption);
          setIsEditing(false);
        };

        const renderFormattedText = (text) => {
          if (!text) return (isRegenerating ? "Thinking..." : "...");
          
          const parts = text.split(/(\*[^*]+\*)/g);
          const colors = ['text-red-500', 'text-blue-500', 'text-green-500', 'text-purple-500', 'text-pink-500'];
          
          return parts.map((part, index) => {
            if (part.startsWith('*') && part.endsWith('*')) {
              const content = part.slice(1, -1);
              // Pick a color based on index or content length to be pseudo-random but consistent
              const colorClass = colors[(index + content.length) % colors.length];
              return <span key={index} className={`${colorClass} font-bold`}>{content}</span>;
            }
            return <span key={index}>{part}</span>;
          });
        };

        return (
          <motion.div
            ref={cardRef}
            initial={{ x: photo.x, y: photo.y, rotate: 0, scale: 0.8, opacity: 0 }}
            animate={{ 
              x: photo.x, 
              y: photo.y, 
              rotate: photo.rotation, 
              scale: 1, 
              opacity: 1,
              filter: `blur(0px)` 
            }}
            drag
            dragMomentum={false}
            onDragEnd={(_, info) => {
              onDragEnd(photo.id, photo.x + info.offset.x, photo.y + info.offset.y);
            }}
            onHoverStart={() => setIsHovered(true)}
            onHoverEnd={() => setIsHovered(false)}
            className="absolute flex flex-col items-center bg-white shadow-xl cursor-grab active:cursor-grabbing select-none"
            style={{
              width: '240px',
              padding: '16px 16px 40px 16px',
              boxShadow: '2px 4px 15px rgba(0,0,0,0.3)',
              zIndex: isHovered ? 50 : 10,
            }}
          >
            {/* Top Toolbar */}
            {isHovered && !isEditing && (
              <div className="photo-tools absolute -top-4 flex gap-2 bg-black/80 rounded-full px-3 py-1 backdrop-blur-sm transition-opacity z-50">
                <button onPointerDown={(e) => e.stopPropagation()} onClick={handleDownload} className="text-white hover:text-blue-300 p-1" title="Download">
                  <Download size={16} />
                </button>
                <button onPointerDown={(e) => e.stopPropagation()} onClick={() => onDelete(photo.id)} className="text-white hover:text-red-400 p-1" title="Delete">
                  <Trash2 size={16} />
                </button>
              </div>
            )}

            {/* Photo Area */}
            <div className="w-full relative overflow-hidden bg-gray-100 aspect-[3/4]">
              <motion.img
                src={photo.imageUrl}
                alt="Memory"
                draggable={false} 
                className="w-full h-full object-cover pointer-events-none md:pointer-events-auto"
                style={{ pointerEvents: 'none' }} 
                initial={{ filter: 'blur(10px) grayscale(100%)' }}
                animate={{ 
                  filter: photo.status === 'developed' ? 'blur(0px) grayscale(0%)' : 'blur(10px) grayscale(100%)'
                }}
                transition={{ duration: 3, ease: "easeOut" }}
              />
              <div className="absolute inset-0 bg-gradient-to-tr from-white/10 to-transparent pointer-events-none mix-blend-overlay"></div>
            </div>

            {/* Caption Area */}
            <div className="w-full mt-4 px-1 relative">
              {isEditing ? (
                <div className="flex flex-col gap-2" onPointerDown={(e) => e.stopPropagation()}>
                  <textarea
                    value={editText}
                    onChange={(e) => setEditText(e.target.value)}
                    className="w-full font-handwritten text-xl text-gray-900 bg-gray-50 border-b border-gray-300 focus:outline-none p-1 resize-none"
                    rows={2}
                    autoFocus
                  />
                  <div className="flex justify-end gap-2">
                    <button onClick={cancelEdit} className="text-red-500 hover:bg-red-50 rounded p-1"><X size={16} /></button>
                    <button onClick={saveEdit} className="text-green-600 hover:bg-green-50 rounded p-1"><Check size={16} /></button>
                  </div>
                </div>
              ) : (
                <div className="relative min-h-[3rem]">
                  <div className="flex justify-between items-end text-gray-400 text-xs font-sans mb-1 select-none">
                    <span>{dateStr}</span>
                  </div>
                  <p 
                    className="font-handwritten text-2xl text-gray-800 leading-6 text-center break-words cursor-text"
                    onDoubleClick={() => setIsEditing(true)}
                  >
                    {renderFormattedText(photo.caption)}
                  </p>
                  
                  {/* Side Controls */}
                  {isHovered && (
                    <div className="photo-tools absolute -right-16 top-1/2 -translate-y-1/2 -translate-x-1/2 flex flex-col gap-2 z-50">
                      <button 
                        onPointerDown={(e) => e.stopPropagation()}
                        onClick={() => setIsEditing(true)}
                        className="bg-white p-2 rounded-full shadow-md hover:bg-gray-50 text-gray-700 transition-transform hover:scale-110"
                        title="Edit Text"
                      >
                        <Edit2 size={18} />
                      </button>
                      <button 
                        onPointerDown={(e) => e.stopPropagation()}
                        onClick={handleRegenerate}
                        disabled={isRegenerating}
                        className={`bg-white p-2 rounded-full shadow-md hover:bg-gray-50 text-gray-700 transition-transform hover:scale-110 ${isRegenerating ? 'cursor-wait' : ''}`}
                        title="Regenerate Caption"
                      >
                        <RefreshCw size={18} className={isRegenerating ? "animate-spin text-blue-500" : ""} />
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>
          </motion.div>
        );
      };

      // --- MAIN APP ---

      const playShutterSound = () => {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
        
        gain.gain.setValueAtTime(0.5, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.15);
      };

      const App = () => {
        const videoRef = useRef(null);
        const [stream, setStream] = useState(null);
        const [photos, setPhotos] = useState([]);
        const [isFlash, setIsFlash] = useState(false);
        const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
        const [showApiKeyModal, setShowApiKeyModal] = useState(!localStorage.getItem('gemini_api_key'));
        
        const browserLang = navigator.language || 'en-US';

        const CAMERA_CONTAINER_WIDTH = 450;
        const CAMERA_CONTAINER_HEIGHT = 450;
        const CAMERA_LEFT = 64;
        const CAMERA_BOTTOM = 64;

        useEffect(() => {
          const startCamera = async () => {
            try {
              const mediaStream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'user', width: { ideal: 720 } }, 
                audio: false 
              });
              setStream(mediaStream);
              if (videoRef.current) {
                videoRef.current.srcObject = mediaStream;
              }
            } catch (err) {
              console.error("Error accessing camera:", err);
              alert("Please allow camera access. If testing on mobile, ensure you are using HTTPS or localhost.");
            }
          };

          startCamera();
          return () => {
            if (stream) stream.getTracks().forEach(track => track.stop());
          };
        }, []);

        const saveApiKey = (key) => {
          localStorage.setItem('gemini_api_key', key);
          setApiKey(key);
          setShowApiKeyModal(false);
        };

        const takePhoto = async () => {
          if (!videoRef.current) return;

          playShutterSound();
          setIsFlash(true);
          setTimeout(() => setIsFlash(false), 150);

          const video = videoRef.current;
          const canvas = document.createElement('canvas');
          const size = Math.min(video.videoWidth, video.videoHeight);
          const width = size * 0.75; 
          const height = size;
          
          canvas.width = 480; 
          canvas.height = 640; 

          const ctx = canvas.getContext('2d');
          if (ctx) {
            const sx = (video.videoWidth - width) / 2;
            const sy = (video.videoHeight - height) / 2;
            
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            ctx.drawImage(video, sx, sy, width, height, 0, 0, canvas.width, canvas.height);
            
            const imageUrl = canvas.toDataURL('image/webp', 0.9);
            
            const containerTop = window.innerHeight - CAMERA_BOTTOM - CAMERA_CONTAINER_HEIGHT;
            const containerLeft = CAMERA_LEFT;
            
            const startX = containerLeft + (CAMERA_CONTAINER_WIDTH / 2) - 120; 
            const startY = containerTop + 50; 

            const ejectedY = containerTop - 200; 

            const newPhoto = {
              id: Date.now().toString(),
              imageUrl,
              caption: '',
              timestamp: Date.now(),
              status: 'developing',
              x: startX,
              y: startY,
              rotation: (Math.random() * 6) - 3 
            };

            setPhotos(prev => [...prev, newPhoto]);

            if (apiKey) {
                generatePhotoCaption({ imageBase64: imageUrl, language: browserLang, apiKey }).then(caption => {
                    setPhotos(current => current.map(p => 
                    p.id === newPhoto.id ? { ...p, caption } : p
                    ));
                });
            } else {
                setPhotos(current => current.map(p => 
                    p.id === newPhoto.id ? { ...p, caption: "Set API Key for AI captions!" } : p
                ));
            }

            setTimeout(() => {
              setPhotos(current => current.map(p => 
                p.id === newPhoto.id ? { ...p, status: 'developed' } : p
              ));
            }, 3500);

            setTimeout(() => {
               setPhotos(current => current.map(p => 
                p.id === newPhoto.id ? { ...p, y: ejectedY } : p
              ));
            }, 100);
          }
        };

        const handleDelete = (id) => {
          setPhotos(prev => prev.filter(p => p.id !== id));
        };

        const handleUpdateCaption = (id, newCaption) => {
          setPhotos(prev => prev.map(p => p.id === id ? { ...p, caption: newCaption } : p));
        };

        const handleDragEnd = (id, x, y) => {
          setPhotos(prev => prev.map(p => p.id === id ? { ...p, x, y } : p));
        };

        return (
          <div className="relative w-screen h-screen overflow-hidden font-sans">
            
            {/* Header */}
            <div className="absolute top-8 left-0 right-0 text-center z-10 pointer-events-none">
              <h1 className="font-handwritten text-5xl text-gray-800 drop-shadow-md">Bao Retro Camera</h1>
            </div>

            {/* API Key Settings Button */}
            <div className="fixed top-8 right-8 z-50">
                 <button 
                    onClick={() => setShowApiKeyModal(true)}
                    className="bg-white/80 p-2 rounded-full shadow hover:bg-white text-gray-600"
                    title="Settings"
                 >
                     <Key size={20} />
                 </button>
            </div>

            {/* Instructions */}
            <div className="fixed bottom-8 right-8 z-10 text-right max-w-xs font-handwritten text-xl text-gray-600 bg-white/80 p-4 rounded-lg shadow-sm backdrop-blur-sm border border-gray-200">
              <div className="flex items-center justify-end gap-2 mb-2 text-gray-800">
                <Info size={20} />
                <span className="font-bold">Instructions</span>
              </div>
              <ul className="list-disc list-inside space-y-1">
                <li>Click the round button to snap.</li>
                <li>Wait for the photo to eject & develop.</li>
                <li>Drag photos to the wall.</li>
                <li>Hover text to edit or regenerate AI caption.</li>
              </ul>
            </div>

            {/* API Key Modal */}
            {showApiKeyModal && (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                        <h2 className="text-xl font-bold mb-4">Gemini API Key</h2>
                        <p className="mb-4 text-sm text-gray-600">To generate AI captions for your photos, please enter your Google Gemini API Key. It will be saved locally in your browser.</p>
                        <input 
                            type="password" 
                            placeholder="Enter API Key (starts with AIza...)" 
                            className="w-full border p-2 rounded mb-4"
                            defaultValue={apiKey}
                            onBlur={(e) => saveApiKey(e.target.value)}
                        />
                        <div className="flex justify-end">
                            <button 
                                onClick={() => setShowApiKeyModal(false)}
                                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                            >
                                Done
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* Photo Wall */}
            <div className="absolute inset-0 z-10 w-full h-full">
              <AnimatePresence>
                {photos.map(photo => (
                  <div 
                    key={photo.id} 
                    className="absolute"
                    style={{ 
                      zIndex: 15 
                    }}
                  >
                    <PhotoCard 
                      photo={photo} 
                      onDelete={handleDelete}
                      onUpdateCaption={handleUpdateCaption}
                      onDragEnd={handleDragEnd}
                      browserLang={browserLang}
                      apiKey={apiKey}
                    />
                  </div>
                ))}
              </AnimatePresence>
            </div>

            {/* Main Camera Container */}
            <div 
              className="fixed"
              style={{
                width: `${CAMERA_CONTAINER_WIDTH}px`,
                height: `${CAMERA_CONTAINER_HEIGHT}px`,
                bottom: `${CAMERA_BOTTOM}px`,
                left: `${CAMERA_LEFT}px`,
                zIndex: 20 
              }}
            >
              {/* Background Image */}
              <img 
                src="https://s.baoyu.io/images/retro-camera.webp" 
                alt="Retro Camera" 
                className="absolute bottom-0 left-0 w-full h-full object-contain select-none pointer-events-none drop-shadow-2xl"
              />

              {/* Flash Overlay */}
              {isFlash && (
                <div className="absolute inset-0 bg-white mix-blend-hard-light opacity-50 rounded-full z-50 animate-pulse" />
              )}

              {/* Viewfinder */}
              <div 
                className="absolute overflow-hidden rounded-full border-4 border-gray-800/50 shadow-inner bg-black"
                style={{
                  bottom: '32%',
                  left: '62%',
                  transform: 'translateX(-50%)',
                  width: '27%',
                  height: '27%',
                  zIndex: 30
                }}
              >
                <video 
                  ref={videoRef}
                  autoPlay 
                  playsInline 
                  muted 
                  className="w-full h-full object-cover transform scale-x-[-1]" 
                />
                <div className="absolute inset-0 bg-gradient-to-tr from-blue-500/20 to-transparent rounded-full pointer-events-none" />
              </div>

              {/* Shutter Button */}
              <button
                onClick={takePhoto}
                className="absolute rounded-full cursor-pointer hover:bg-white/10 active:bg-black/20 transition-colors"
                style={{
                  bottom: '40%',
                  left: '18%',
                  width: '11%',
                  height: '11%',
                  zIndex: 30
                }}
                title="Take Photo"
                aria-label="Take Photo"
              />
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>